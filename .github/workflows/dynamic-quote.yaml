name: Dynamic Quote Update

on:
  schedule:
    - cron: '*/10 * * * *'  # Runs every 2 minutes
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: write

jobs:
  update-quote:
    runs-on: ubuntu-latest
    name: Update Dynamic Quote
    steps:
      - uses: actions/checkout@v4

      - name: Fetch Random Quote from API
        id: quote
        run: |
          # Try multiple quote APIs for reliability
          
          # First try: Quotable API (programming/technology quotes)
          if quote_data=$(curl -s "https://api.quotable.io/quotes/random?tags=technology,science,inspirational&limit=1"); then
            quote_text=$(echo "$quote_data" | jq -r '.[0].content // .content')
            quote_author=$(echo "$quote_data" | jq -r '.[0].author // .author')
            
            if [ "$quote_text" != "null" ] && [ "$quote_author" != "null" ]; then
              selected_quote="$quote_text ‚Äì $quote_author"
              echo "‚úÖ Got quote from Quotable API"
            else
              quote_data=""
            fi
          fi
          
          # Fallback: ZenQuotes API
          if [ -z "$quote_data" ] || [ "$quote_text" = "null" ]; then
            echo "üîÑ Trying ZenQuotes API..."
            if quote_response=$(curl -s "https://zenquotes.io/api/random"); then
              quote_text=$(echo "$quote_response" | jq -r '.[0].q // empty')
              quote_author=$(echo "$quote_response" | jq -r '.[0].a // empty')
              
              if [ -n "$quote_text" ] && [ -n "$quote_author" ] && [ "$quote_text" != "null" ]; then
                selected_quote="$quote_text ‚Äì $quote_author"
                echo "‚úÖ Got quote from ZenQuotes API"
              fi
            fi
          fi
          
          # Final fallback: Hardcoded tech quotes
          if [ -z "$selected_quote" ]; then
            echo "üîÑ Using fallback quotes..."
            quotes=(
              "Code is like humor. When you have to explain it, it's bad. ‚Äì Cory House"
              "First, solve the problem. Then, write the code. ‚Äì John Johnson"
              "Talk is cheap. Show me the code. ‚Äì Linus Torvalds"
              "The best error message is the one that never shows up. ‚Äì Thomas Fuchs"
              "Make it work, make it right, make it fast. ‚Äì Kent Beck"
              "Any fool can write code that a computer can understand. Good programmers write code that humans can understand. ‚Äì Martin Fowler"
              "Programs must be written for people to read, and only incidentally for machines to execute. ‚Äì Harold Abelson"
              "Innovation distinguishes between a leader and a follower. ‚Äì Steve Jobs"
              "Technology is best when it brings people together. ‚Äì Matt Mullenweg"
              "Simplicity is the ultimate sophistication. ‚Äì Leonardo da Vinci"
            )
            
            random_index=$((RANDOM % ${#quotes[@]}))
            selected_quote="${quotes[$random_index]}"
            echo "‚úÖ Using fallback quote"
          fi
          
          # Get current timestamp
          timestamp=$(date '+%B %d, %Y at %I:%M %p UTC')
          
          echo "quote=$selected_quote" >> $GITHUB_OUTPUT
          echo "timestamp=$timestamp" >> $GITHUB_OUTPUT
          echo "üéØ Selected quote: $selected_quote"

      - name: Update README with new quote
        run: |
          # Create temp file with new quote content
          cat > new_quote.md << EOF
          ### üí° *"${{ steps.quote.outputs.quote }}"*

          *Last updated: ${{ steps.quote.outputs.timestamp }}*
          EOF
          
          # Use Python for reliable text replacement
          python3 << 'PYTHON_SCRIPT'
          import re
          
          # Read current README
          with open('README.md', 'r', encoding='utf-8') as f:
              content = f.read()
          
          # Read new quote content
          with open('new_quote.md', 'r', encoding='utf-8') as f:
              new_quote = f.read().strip()
          
          # Replace content between markers
          pattern = r'(<!--DYNAMIC_QUOTE:start-->).*?(<!--DYNAMIC_QUOTE:end-->)'
          replacement = r'\1\n' + new_quote + r'\n\2'
          
          updated_content = re.sub(pattern, replacement, content, flags=re.DOTALL)
          
          # Write back to README
          with open('README.md', 'w', encoding='utf-8') as f:
              f.write(updated_content)
          
          print("‚úÖ README updated successfully")
          PYTHON_SCRIPT
          
          # Clean up
          rm -f new_quote.md

      - name: Commit changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "Quote Bot"
          git add README.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "üí≠ Update dynamic quote [skip ci]"
            
            # Handle potential push conflicts with retries
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if git push; then
                echo "‚úÖ Successfully pushed quote update"
                break
              else
                echo "‚ö†Ô∏è Push failed, attempting to pull and retry (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
                RETRY_COUNT=$((RETRY_COUNT + 1))
                
                # Pull latest changes and rebase our commit
                git pull --rebase origin main
                
                # If this is the last retry, fail
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "‚ùå Failed to push after $MAX_RETRIES attempts"
                  exit 1
                fi
                
                # Wait a bit before retrying to avoid rapid succession
                sleep 3
              fi
            done
          fi
